'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const getPuppeteerType = (instance)=>{
    if (instance?.constructor?.name && [
        "CDPPage",
        "Frame",
        "ElementHandle"
    ].includes(instance.constructor.name) && instance.$) {
        return instance.constructor.name;
    }
    return null;
};
const getContext = async (instance, pageFunction)=>{
    const type = getPuppeteerType(instance);
    switch(type){
        case "CDPPage":
        case "Frame":
            return {
                page: instance,
                handle: await instance.evaluateHandle(pageFunction)
            };
        case "ElementHandle":
            {
                return {
                    page: instance.frame,
                    handle: instance
                };
            }
        default:
            throw new Error(`${type} is not implemented`);
    }
};
const enhanceError = (error, message)=>{
    error.message = `${message}\n${error.message}`;
    return error;
};
const isRegExp = (input)=>Object.prototype.toString.call(input) === "[object RegExp]";
const expandSearchExpr = (expr)=>{
    if (isRegExp(expr)) return {
        text: null,
        regexp: expr.toString()
    };
    if (typeof expr === "string") return {
        text: expr,
        regexp: null
    };
    return {
        text: null,
        regexp: null
    };
};

let defaultOptionsValue = {
    timeout: 500
};
const setDefaultOptions = (options)=>{
    defaultOptionsValue = options;
};
const getDefaultOptions = ()=>{
    if (global.puppeteerConfig && (global.puppeteerConfig.launch && global.puppeteerConfig.launch.slowMo || global.puppeteerConfig.connect && global.puppeteerConfig.connect.slowMo) && defaultOptionsValue && defaultOptionsValue.timeout) {
        return {
            ...defaultOptionsValue,
            // Multiplying slowMo by 10 is just arbitrary
            // slowMo is applied on all Puppeteer internal methods, so it is just a "slow" indicator
            // we can't use it as a real value
            timeout: defaultOptionsValue.timeout + global.puppeteerConfig.launch.slowMo * 10
        };
    }
    return defaultOptionsValue;
};
const defaultOptions = (options)=>({
        ...getDefaultOptions(),
        ...options
    });

async function notToMatch(instance, matcher, options) {
    options = defaultOptions(options);
    const { traverseShadowRoots =false  } = options;
    const { page , handle  } = await getContext(instance, ()=>document.body);
    try {
        await page.waitForFunction((handle, matcher, traverseShadowRoots)=>{
            function getShadowTextContent(node) {
                const walker = document.createTreeWalker(node, // eslint-disable-next-line no-bitwise
                NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
                let result = "";
                let currentNode = walker.nextNode();
                while(currentNode){
                    if (currentNode.assignedSlot) {
                        // Skip everything within this subtree, since it's assigned to a slot in the shadow DOM.
                        const nodeWithAssignedSlot = currentNode;
                        while(currentNode === nodeWithAssignedSlot || nodeWithAssignedSlot.contains(currentNode)){
                            currentNode = walker.nextNode();
                        }
                        continue;
                    } else if (currentNode.nodeType === Node.TEXT_NODE) {
                        result += currentNode.textContent;
                    } else if (currentNode.shadowRoot) {
                        result += getShadowTextContent(currentNode.shadowRoot);
                    } else if (typeof currentNode.assignedNodes === "function") {
                        const assignedNodes = currentNode.assignedNodes();
                        // eslint-disable-next-line no-loop-func
                        assignedNodes.forEach((node)=>{
                            result += getShadowTextContent(node);
                        });
                    }
                    currentNode = walker.nextNode();
                }
                return result;
            }
            if (!handle) return false;
            const textContent = traverseShadowRoots ? getShadowTextContent(handle) : handle.textContent;
            return textContent.match(new RegExp(matcher)) === null;
        }, options, handle, matcher, traverseShadowRoots);
    } catch (error) {
        throw enhanceError(error, `Text found "${matcher}"`);
    }
}

async function notToMatchElement(instance, selector, { text , ...options } = {}) {
    options = defaultOptions(options);
    const { page , handle  } = await getContext(instance, ()=>document);
    try {
        await page.waitForFunction((handle, selector, text)=>{
            const elements = handle.querySelectorAll(selector);
            if (text !== undefined) {
                return [
                    ...elements
                ].every(({ textContent  })=>!textContent.match(text));
            }
            return elements.length === 0;
        }, options, handle, selector, text);
    } catch (error) {
        throw enhanceError(error, `Element ${selector}${text !== undefined ? ` (text: "${text}") ` : " "}found`);
    }
}

async function toMatchElement(instance, selector, { text: searchExpr , visible =false , ...options } = {}) {
    options = defaultOptions(options);
    selector = selector instanceof Object ? {
        ...selector
    } : {
        type: "css",
        value: selector
    };
    const { page , handle  } = await getContext(instance, ()=>document);
    const { text , regexp  } = expandSearchExpr(searchExpr);
    const getElement = (handle, selector, text, regexp, visible)=>{
        function hasVisibleBoundingBox(element) {
            const rect = element.getBoundingClientRect();
            return !!(rect.top || rect.bottom || rect.width || rect.height);
        }
        const isVisible = (element)=>{
            if (visible) {
                const style = window.getComputedStyle(element);
                return style && style.visibility !== "hidden" && hasVisibleBoundingBox(element);
            }
            return true;
        };
        let nodes = [];
        switch(selector.type){
            case "xpath":
                {
                    const xpathResults = document.evaluate(selector.value, handle);
                    let currentXpathResult = xpathResults.iterateNext();
                    while(currentXpathResult){
                        nodes.push(currentXpathResult);
                        currentXpathResult = xpathResults.iterateNext();
                    }
                    break;
                }
            case "css":
                nodes = handle.querySelectorAll(selector.value);
                break;
            default:
                throw new Error(`${selector.type} is not implemented`);
        }
        const elements = [
            ...nodes
        ].filter(isVisible);
        if (regexp !== null) {
            const [, pattern, flags] = regexp.match(/\/(.*)\/(.*)?/);
            return elements.find(({ textContent  })=>textContent.replace(/\s+/g, " ").trim().match(new RegExp(pattern, flags)));
        }
        if (text !== null) {
            return elements.find(({ textContent  })=>textContent.replace(/\s+/g, " ").trim().includes(text));
        }
        return elements[0];
    };
    try {
        await page.waitForFunction(getElement, options, handle, selector, text, regexp, visible);
    } catch (error) {
        throw enhanceError(error, `Element ${selector.value}${text !== null || regexp !== null ? ` (text: "${text || regexp}") ` : " "}not found`);
    }
    const jsHandle = await page.evaluateHandle(getElement, handle, selector, text, regexp, visible);
    return jsHandle.asElement();
}

async function toClick(instance, selector, options) {
    const element = await toMatchElement(instance, selector, options);
    await element.click(options);
}

async function toDisplayDialog(page, block) {
    return new Promise((resolve, reject)=>{
        const handleDialog = (dialog)=>{
            page.removeListener("dialog", handleDialog);
            resolve(dialog);
        };
        page.on("dialog", handleDialog);
        block().catch(reject);
    });
}

async function selectAll(element) {
    // modified from https://github.com/microsoft/playwright/issues/849#issuecomment-587983363
    await element.evaluate((elementHandle)=>{
        if (elementHandle.setSelectionRange) {
            try {
                elementHandle.setSelectionRange(0, elementHandle.value.length);
            } catch (e) {
                // setSelectionRange throws an error for inputs: number/date/time/etc
                // we can just focus them and the content will be selected
                elementHandle.focus();
                elementHandle.select();
            }
        } else if (window.getSelection && document.createRange) {
            const range = document.createRange();
            range.selectNodeContents(elementHandle);
            const selection = window.getSelection();
            if (selection) {
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }
    });
}
async function toFill(instance, selector, value, options) {
    const { delay , ...toMatchElementOptions } = options || {};
    const element = await toMatchElement(instance, selector, toMatchElementOptions);
    await selectAll(element);
    await element.press("Delete");
    await element.type(value, {
        delay
    });
}

/* eslint-disable no-restricted-syntax, no-await-in-loop */ async function toFillForm(instance, selector, values, options) {
    options = defaultOptions(options);
    const form = await toMatchElement(instance, selector, options);
    for (const name of Object.keys(values)){
        await toFill(form, `[name="${name}"]`, values[name], options);
    }
}

async function toMatch(instance, matcher, options) {
    options = defaultOptions(options);
    const { traverseShadowRoots =false  } = options;
    const { page , handle  } = await getContext(instance, ()=>document.body);
    const { text , regexp  } = expandSearchExpr(matcher);
    try {
        await page.waitForFunction((handle, text, regexp, traverseShadowRoots)=>{
            function getShadowTextContent(node) {
                const walker = document.createTreeWalker(node, // eslint-disable-next-line no-bitwise
                NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
                let result = "";
                let currentNode = walker.nextNode();
                while(currentNode){
                    if (currentNode.assignedSlot) {
                        // Skip everything within this subtree, since it's assigned to a slot in the shadow DOM.
                        const nodeWithAssignedSlot = currentNode;
                        while(currentNode === nodeWithAssignedSlot || nodeWithAssignedSlot.contains(currentNode)){
                            currentNode = walker.nextNode();
                        }
                        continue;
                    } else if (currentNode.nodeType === Node.TEXT_NODE) {
                        result += currentNode.textContent;
                    } else if (currentNode.shadowRoot) {
                        result += getShadowTextContent(currentNode.shadowRoot);
                    } else if (typeof currentNode.assignedNodes === "function") {
                        const assignedNodes = currentNode.assignedNodes();
                        // eslint-disable-next-line no-loop-func
                        assignedNodes.forEach((node)=>{
                            result += getShadowTextContent(node);
                        });
                    }
                    currentNode = walker.nextNode();
                }
                return result;
            }
            if (!handle) return false;
            const textContent = traverseShadowRoots ? getShadowTextContent(handle) : handle.textContent;
            if (regexp !== null) {
                const [, pattern, flags] = regexp.match(/\/(.*)\/(.*)?/);
                return textContent.replace(/\s+/g, " ").trim().match(new RegExp(pattern, flags)) !== null;
            }
            if (text !== null) {
                return textContent.replace(/\s+/g, " ").trim().includes(text);
            }
            return false;
        }, options, handle, text, regexp, traverseShadowRoots);
    } catch (error) {
        throw enhanceError(error, `Text not found "${matcher}"`);
    }
}

function select(page, element, value) {
    return page.evaluate((element, value)=>{
        if (element.nodeName.toLowerCase() !== "select") throw new Error("Element is not a <select> element.");
        const options = Array.from(element.options);
        element.value = undefined;
        for (const option of options){
            option.selected = value === option.value;
            if (option.selected && !element.multiple) break;
        }
        element.dispatchEvent(new Event("input", {
            bubbles: true
        }));
        element.dispatchEvent(new Event("change", {
            bubbles: true
        }));
        return options.filter((option)=>option.selected).map((option)=>option.value);
    }, element, value);
}
async function toSelect(instance, selector, valueOrText, options) {
    const element = await toMatchElement(instance, selector, options);
    const optionElements = await element.$$("option");
    const optionsAttributes = await Promise.all(optionElements.map(async (option)=>{
        const textContentProperty = await option.getProperty("textContent");
        const valueProperty = await option.getProperty("value");
        return {
            value: await valueProperty.jsonValue(),
            textContent: await textContentProperty.jsonValue()
        };
    }));
    const option = optionsAttributes.find(({ value , textContent  })=>value === valueOrText || textContent === valueOrText);
    if (!option) {
        throw new Error(`Option not found "${selector}" ("${valueOrText}")`);
    }
    const { page  } = await getContext(instance, ()=>document);
    await select(page, element, option.value);
// await page.select(selector, foundValue)
// console.log(select.select)
// select.select()
// const foundValue = await select.$$eval(
//   `${selector} option`,
//   (options, valueOrText, selector) => {
//     const option = options.find(
//       option =>
//         option.value === valueOrText || option.textContent === valueOrText,
//     )
//     if (!option) {
//       throw new Error(`Option not found "${selector}" ("${valueOrText}")`)
//     }
//     return option.value
//   },
//   valueOrText,
//   selector,
// )
//
// await page.select(selector, foundValue)
}

async function toUploadFile(instance, selector, file, options) {
    const input = await toMatchElement(instance, selector, options);
    const files = Array.isArray(file) ? file : [
        file
    ];
    await input.uploadFile(...files);
}

const pageMatchers = {
    toClick,
    toDisplayDialog,
    toFill,
    toFillForm,
    toMatch,
    toMatchElement,
    toSelect,
    toUploadFile,
    not: {
        toMatch: notToMatch,
        toMatchElement: notToMatchElement
    }
};
const elementHandleMatchers = {
    toClick,
    toFill,
    toFillForm,
    toMatch,
    toMatchElement,
    toSelect,
    toUploadFile,
    not: {
        toMatch: notToMatch,
        toMatchElement: notToMatchElement
    }
};
function createMatcher(matcher, page) {
    return async function throwingMatcher(...args) {
        if (typeof global.expect !== "undefined") {
            global.expect.getState().assertionCalls += 1;
        }
        try {
            return await matcher(page, ...args);
        } catch (error) {
            Error.captureStackTrace(error, throwingMatcher);
            throw error;
        }
    };
}
function internalExpect(type, matchers) {
    const expectation = {
        not: {}
    };
    Object.keys(matchers).forEach((key)=>{
        if (key === "not") return;
        expectation[key] = createMatcher(matchers[key], type);
    });
    Object.keys(matchers.not).forEach((key)=>{
        expectation.not[key] = createMatcher(matchers.not[key], type);
    });
    return expectation;
}
function expectPuppeteer(actual) {
    const type = getPuppeteerType(actual);
    switch(type){
        case "CDPPage":
        case "Frame":
            return internalExpect(actual, pageMatchers);
        case "ElementHandle":
            return internalExpect(actual, elementHandleMatchers);
        default:
            throw new Error(`${actual} is not supported`);
    }
}
if (typeof global.expect !== "undefined") {
    const originalExpect = global.expect;
    global.expect = (actual, ...args)=>{
        const type = getPuppeteerType(actual);
        if (type) {
            const matchers = expectPuppeteer(actual);
            const jestMatchers = originalExpect(actual, ...args);
            return {
                ...jestMatchers,
                ...matchers,
                not: {
                    ...jestMatchers.not,
                    ...matchers.not
                }
            };
        }
        return originalExpect(actual, ...args);
    };
    Object.keys(originalExpect).forEach((prop)=>{
        global.expect[prop] = originalExpect[prop];
    });
}

exports.getDefaultOptions = getDefaultOptions;
exports.setDefaultOptions = setDefaultOptions;
