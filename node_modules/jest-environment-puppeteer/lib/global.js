'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jestDevServer = require('jest-dev-server');
var chalk = require('chalk');
var fs = require('fs');
var path = require('path');
var util = require('util');
var cwd = require('cwd');
var merge = require('merge-deep');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var cwd__default = /*#__PURE__*/_interopDefaultLegacy(cwd);
var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);

const exists = util.promisify(fs__default["default"].exists);
const DEFAULT_CONFIG = {
    launch: {},
    browserContext: "default",
    exitOnPageError: true
};
const DEFAULT_CONFIG_CI = merge__default["default"](DEFAULT_CONFIG, {
    launch: {
        args: [
            "--no-sandbox",
            "--disable-setuid-sandbox",
            "--disable-background-timer-throttling",
            "--disable-backgrounding-occluded-windows",
            "--disable-renderer-backgrounding"
        ]
    }
});
async function readConfig() {
    const defaultConfig = process.env.CI === "true" ? DEFAULT_CONFIG_CI : DEFAULT_CONFIG;
    const hasCustomConfigPath = !!process.env.JEST_PUPPETEER_CONFIG;
    const configPath = process.env.JEST_PUPPETEER_CONFIG || "jest-puppeteer.config.js";
    const absConfigPath = path__default["default"].resolve(cwd__default["default"](), configPath);
    const configExists = await exists(absConfigPath);
    if (hasCustomConfigPath && !configExists) {
        throw new Error(`Error: Can't find a root directory while resolving a config file path.\nProvided path to resolve: ${configPath}`);
    }
    if (!hasCustomConfigPath && !configExists) {
        return defaultConfig;
    }
    const localConfig = await require(absConfigPath);
    const product = localConfig.launch ? localConfig.launch.product : undefined;
    // Move browser config to launch.product
    if (product === undefined && localConfig.browser) {
        // eslint-disable-next-line no-console
        console.warn("`browser` config has been deprecated and will be removed in future versions. Use `launch.product` config with `chrome` or `firefox` instead.");
        let launch = {};
        if (localConfig.launch) {
            launch = localConfig.launch;
        }
        launch.product = localConfig.browser === "chromium" ? "chrome" : localConfig.browser;
        localConfig.launch = launch;
    }
    // Ensure that launch.product is equal to 'chrome', or 'firefox'
    if (product !== undefined && ![
        "chrome",
        "firefox"
    ].includes(product)) {
        throw new Error(`Error: Invalid product value '${product}'`);
    }
    return merge__default["default"]({}, defaultConfig, localConfig);
}
function getPuppeteer() {
    try {
        return require("puppeteer");
    } catch (e) {
        return require("puppeteer-core");
    }
}

let browsers = [];
let didAlreadyRunInWatchMode = false;
async function openBrowser(puppeteer, config) {
    if (config.connect) {
        return puppeteer.connect(config.connect);
    }
    return puppeteer.launch(config.launch);
}
async function setup(jestConfig = {}) {
    const config = await readConfig();
    const puppeteer = getPuppeteer();
    const browsersCount = config.browserPerWorker && !config.connect ? jestConfig.maxWorkers : 1;
    process.env.BROWSERS_COUNT = browsersCount;
    let wsEndpoints = [];
    if (config.connect && config.connect.browserWSEndpoint) {
        wsEndpoints = [
            config.connect.browserWSEndpoint
        ];
    } else {
        browsers = await Promise.all(Array.from({
            length: browsersCount
        }).map(()=>openBrowser(puppeteer, config)));
        wsEndpoints = browsers.map((browser)=>browser.wsEndpoint());
    }
    process.env.PUPPETEER_WS_ENDPOINTS = JSON.stringify(wsEndpoints);
    // If we are in watch mode, - only setupServer() once.
    if (jestConfig.watch || jestConfig.watchAll) {
        if (didAlreadyRunInWatchMode) return;
        didAlreadyRunInWatchMode = true;
    }
    if (config.server) {
        try {
            await jestDevServer.setup(config.server);
        } catch (error) {
            if (error.code === jestDevServer.ERROR_TIMEOUT) {
                console.log("");
                console.error(chalk__default["default"].red(error.message));
                console.error(chalk__default["default"].blue(`\n☝️ You can set "server.launchTimeout" in jest-puppeteer.config.js`));
                process.exit(1);
            }
            if (error.code === jestDevServer.ERROR_NO_COMMAND) {
                console.log("");
                console.error(chalk__default["default"].red(error.message));
                console.error(chalk__default["default"].blue(`\n☝️ You must set "server.command" in jest-puppeteer.config.js`));
                process.exit(1);
            }
            throw error;
        }
    }
}
async function teardown(jestConfig = {}) {
    const config = await readConfig();
    await Promise.all(browsers.map((browser)=>{
        if (config.connect) {
            return browser.disconnect();
        }
        return browser.close().catch((e)=>{
            console.error(`global.js teardown: Error closing browser ${e.stack}`);
        });
    }));
    if (!jestConfig.watch && !jestConfig.watchAll) {
        await jestDevServer.teardown();
    }
}

exports.setup = setup;
exports.teardown = teardown;
